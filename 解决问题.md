你的 Python 文件写得基本没问题，但根据你前面 Qt/C++ 调用 Python 时出现的错误信息：

javascript
复制
编辑
Failed to find callable function 'process_images' in Python module.
这提示并不是 process_images 没有定义，而是你在 C++ 中调用的是 main 函数，但错误信息却在说 process_images 找不到。这通常说明你加载了错误的模块，或者函数名写错了。现在我们来逐步检查并修复。

✅ 1. 检查 C++ 中调用的函数名是否一致
你 C++ 中这部分写的是：

cpp
复制
编辑
PyObject *pFunc = PyObject_GetAttrString(pModule, "main");
if (!pFunc || !PyCallable_Check(pFunc)) {
    qDebug() << "Failed to find callable function 'process_images' in Python module.";
    PyErr_Print();
    ...
}
🔴 问题是你获取的是 main 函数，但错误提示却是 process_images，这说明你输出的调试信息不对，应该改成这样：

cpp
复制
编辑
qDebug() << "Failed to find callable function 'main' in Python module.";
所以你只是打印错了错误函数名，但你调用的是 main，这是正确的。

✅ 2. 检查 Python 文件名与 C++ 一致
你写了：

cpp
复制
编辑
QString pyFile = "Ddataset_jiaoben";
PyObject *pModule = PyImport_ImportModule("Ddataset_jiaoben");
请确保文件实际路径是这个：E:/Yangranran/decon/sparse-deconv-py/Ddataset_jiaoben.py

且文件名必须和模块名一致，不能写成 Ddataset_jiaoben (1).py、Ddataset_jiaoben.py.txt 等。否则 Python 加载模块时会失败。

✅ 3. 检查 Python 文件目录是否被加入了 sys.path
你写了：

cpp
复制
编辑
PyRun_SimpleString("sys.path.append('./')");
这里的 './' 指的是Qt 程序运行时的当前目录，可能不是 Ddataset_jiaoben.py 所在路径。

✅ 建议加一句：

cpp
复制
编辑
PyRun_SimpleString("sys.path.append('E:/Yangranran/decon/sparse-deconv-py')");
✅ 4. 检查 Python 文件内的 main() 是否能成功执行
你已经这样定义：

python
复制
编辑
def main():
    ...
    process_images(default_input_dir, default_output_file)
    return 0
这部分没问题。

✅ 5. 可选：用 PyErr_Print() 查看详细错误日志
你调用：

cpp
复制
编辑
PyErr_Print();
应该能看到诸如：

vbnet
复制
编辑
ModuleNotFoundError: No module named 'Ddataset_jiaoben'
或者：

pgsql
复制
编辑
AttributeError: module 'Ddataset_jiaoben' has no attribute 'main'
请在 Qt 的调试窗口查看这些报错信息，会非常关键。

✅ 建议修改的 C++ 代码片段（关键改动标注了注释）
cpp
复制
编辑
// 添加 Python 脚本路径（必须是脚本所在路径）
PyRun_SimpleString("import sys");
PyRun_SimpleString("sys.path.append('E:/Yangranran/decon/sparse-deconv-py')"); // 关键路径

PyObject *pModule = PyImport_ImportModule("Ddataset_jiaoben");
if (!pModule) {
    qDebug() << "Failed to load Python module:" << pyFile;
    PyErr_Print();
    Py_Finalize();
    return -1;
}

PyObject *pFunc = PyObject_GetAttrString(pModule, "main");
if (!pFunc || !PyCallable_Check(pFunc)) {
    qDebug() << "Failed to find callable function 'main' in Python module.";  // 修正输出信息
    PyErr_Print();
    Py_XDECREF(pModule);
    Py_Finalize();
    return -1;
}
✅ 总结
🔍 请重点确认以下几点：

Ddataset_jiaoben.py 是否确实在目录 E:/Yangranran/decon/sparse-deconv-py/

.py 文件名是否正确（无空格或隐藏扩展名）

是否 main() 函数存在

sys.path.append(...) 是否加了真实路径

Qt 日志是否输出了更详细的 Python 错误（PyErr_Print()）

你可以尝试运行下更新后看看还有没有报错，我可以继续帮你 debug。


-----------------------------------------

你这段 Qt 调用 Python 的流程总体是合理的，但出错信息 "Failed to execute Python function 'main'！！！！." 表示执行 Python 函数时出了问题，并且你 Python 脚本中在 main() 里调用了 sys.exit(0) 或 exit(0)，这实际上会终止整个 Python 解释器，导致 Qt 之后无法处理 Python 的调用结果，也无法执行后续任务。

✅ 问题定位
在你 Python 脚本的 main() 函数中有这两行：

python
复制
编辑
sys.exit(0)
return 0
并且在 process_images() 函数中也有：

python
复制
编辑
exit(0)
这些 exit(0) 或 sys.exit(0) 在嵌入式环境（如 Qt 嵌入 Python）中是不被推荐使用的。它们会直接导致 整个 Python 解释器关闭，从而 Qt 无法再继续使用 Python API，最终出现你看到的错误。

✅ 修改建议
你需要删除所有的 exit(0) 或 sys.exit(0)，并仅保留函数返回值，例如：

python
复制
编辑
def main():
    default_input_dir = "E:/Yangranran/exercise/Microsystem/BUILD/3Dscanning/188/ROI"
    default_output_file = "E:/Yangranran/exercise/Microsystem/BUILD/3Dscanning/188/3Ddata/1_microscope_volume30.tif"

    process_images(default_input_dir, default_output_file)
    return 0  # 返回值供 Qt 使用
再将 process_images() 中的结尾也改成：

python
复制
编辑
print("图像处理完成，结果已保存:", saveimage_dir)
# exit(0)   ← 不要这句
✅ Qt 部分小建议
如果你在 Qt 中通过 PyObject_CallObject 执行了 main()，那最好你能检查 pResult 的返回值，例如：

cpp
复制
编辑
if (PyLong_Check(pResult)) {
    long resultCode = PyLong_AsLong(pResult);
    qDebug() << "Python main() return code:" << resultCode;
}
✅ 总结

问题	解决方法
Python 中使用了 exit(0) 或 sys.exit(0)	删除所有 exit() 和 sys.exit()，仅用 return 退出函数
Qt 中显示 Python 函数执行失败	原因是 exit() 直接终止了 Python 解释器
你改完后再试一下，Qt 应该就能顺利调用 main() 并继续运行下一步了。如果还有异常，我可以帮你再 debug。要不要我顺便也帮你把这个 Python 脚本整理成一个兼容 Qt 嵌入环境的版本？
